"use strict";

var _typeof = require("@babel/runtime-corejs3/helpers/typeof");

var _WeakMap = require("@babel/runtime-corejs3/core-js-stable/weak-map");

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js-stable/object/define-property");

var _Object$getOwnPropertyDescriptor = require("@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor");

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

var _concat = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/concat"));

var _keys = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/keys"));

var _isArray = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/array/is-array"));

var _forEach = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/for-each"));

var _stringify = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/json/stringify"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));

var utils = _interopRequireWildcard(require("./utils"));

var _reqlib = require("reqlib");

function _getRequireWildcardCache(nodeInterop) { if (typeof _WeakMap !== "function") return null; var cacheBabelInterop = new _WeakMap(); var cacheNodeInterop = new _WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = _Object$defineProperty && _Object$getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? _Object$getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { _Object$defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var Core = /*#__PURE__*/function () {
  function Core(config, request) {
    var _context;

    (0, _classCallCheck2["default"])(this, Core);
    this.config = config;
    this.paramExcludes = (0, _concat["default"])(_context = (0, _keys["default"])(config)).call(_context, ['_create', '_id', '_index', '_indices', '_source']);
    this.request = request || new _reqlib.Request(config);
  } // http://www.elasticsearch.org/guide/reference/api/index_/
  // .add to ease backwards compatibility


  (0, _createClass2["default"])(Core, [{
    key: "add",
    value: function add() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var doc = arguments.length > 1 ? arguments[1] : undefined;
      var callback = arguments.length > 2 ? arguments[2] : undefined;

      if (!callback && typeof doc === 'function') {
        callback = doc;
        doc = options;
        options = {};
      } // handle scenarios where options are not provided


      if (!doc) {
        doc = options;
        options = {};
      }

      var err = utils.optionsUndefined(options, this.config, ['_index']);

      if (err) {
        return utils.promiseRejectOrCallback(err, callback);
      } // check for _create


      var endpointName = options.create || options._create ? '_create' : '';
      endpointName = endpointName || '_doc';
      var index = utils.getIndexSyntax(options, this.config);
      options.query = utils.exclude(options, this.paramExcludes);
      options.path = utils.pathAppend(index, endpointName, options._id);

      if (options._id) {
        return this.request.put(options, doc, callback);
      } else {
        return this.request.post(options, doc, callback);
      }
    } // http://www.elasticsearch.org/guide/reference/api/bulk/
    // Note: Formats input queries as follows in POST data:
    //
    // { header : {} } \n
    // { data : {} } \n
    // { header : {} } \n
    // { data : {} } \n
    //

  }, {
    key: "bulk",
    value: function bulk() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var commands = arguments.length > 1 ? arguments[1] : undefined;
      var callback = arguments.length > 2 ? arguments[2] : undefined;

      if (!callback && typeof commands === 'function') {
        callback = commands;
        commands = options;
        options = {};
      } // handle scenarios where options are not provided


      if (!commands) {
        commands = options;
        options = {};
      }

      if (!(0, _isArray["default"])(commands)) {
        return utils.promiseRejectOrCallback(new Error('commands provided must be in array format'), callback);
      }

      var index = utils.getIndexSyntax(options, null),
          // specifically don't want default settings
      serializedCommands = '';
      options.query = utils.exclude(options, this.paramExcludes);
      options.path = utils.pathAppend(index, '_bulk');
      (0, _forEach["default"])(commands).call(commands, function (command) {
        serializedCommands += (0, _stringify["default"])(command) + '\n';
      });
      return this.request.post(options, serializedCommands, callback);
    } // convenience method for bulk that specifies index action
    // and automatically creates appropriate action/meta entries
    // for the documents passed

  }, {
    key: "bulkIndex",
    value: function bulkIndex() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var documents = arguments.length > 1 ? arguments[1] : undefined;
      var callback = arguments.length > 2 ? arguments[2] : undefined;

      if (!callback && typeof documents === 'function') {
        callback = documents;
        documents = options;
        options = {};
      } // handle scenarios where options are not provided


      if (!documents) {
        documents = options;
        options = {};
      }

      if (!(0, _isArray["default"])(documents)) {
        return utils.promiseRejectOrCallback(new Error('documents provided must be in array format'), callback);
      }

      var action = {},
          commands = [],
          index = utils.getIndexSyntax(options, this.config);
      (0, _forEach["default"])(documents).call(documents, function (document) {
        action = {
          index: {
            _index: index
          }
        }; // fix for issue #28, ability to handle _id property on document

        if (document.hasOwnProperty('_id')) {
          action.index._id = document._id;
          delete document._id;
        }

        commands.push(action);
        commands.push(document);
      });
      return this.bulk(options, commands, callback);
    } // http://www.elasticsearch.org/guide/reference/api/count/

  }, {
    key: "count",
    value: function count() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var query = arguments.length > 1 ? arguments[1] : undefined;
      var callback = arguments.length > 2 ? arguments[2] : undefined;

      if (!callback && typeof query === 'function') {
        callback = query;
        query = options;
        options = {};
      }

      if (!callback && !query && typeof options === 'function') {
        callback = options;
        query = null;
        options = {};
      } // correct situation if count is called without a query


      if (query && !query.query) {
        options = query;
        query = null;
      } // look for scenarios where options are omitted


      if (!query && options.query) {
        query = options;
        options = {};
      }

      var index = utils.getIndexSyntax(options, this.config);
      options.query = utils.exclude(options, this.paramExcludes);
      options.path = utils.pathAppend(index, '_count');

      if (query) {
        return this.request.post(options, query, callback);
      } else {
        return this.request.get(options, callback);
      }
    } // http://www.elasticsearch.org/guide/reference/api/delete/

  }, {
    key: "delete",
    value: function _delete() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var callback = arguments.length > 1 ? arguments[1] : undefined;

      if (!callback && typeof options === 'function') {
        callback = options;
        options = {};
      }

      var err = utils.optionsUndefined(options, this.config, ['_index']);

      if (err) {
        return utils.promiseRejectOrCallback(err, callback);
      }

      var index = utils.getIndexSyntax(options, this.config);
      options.query = utils.exclude(options, this.paramExcludes);
      options.path = utils.pathAppend(index, '_doc', options._id);
      return this.request["delete"](options, callback);
    } // http://www.elasticsearch.org/guide/reference/api/delete-by-query/

  }, {
    key: "deleteByQuery",
    value: function deleteByQuery() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var query = arguments.length > 1 ? arguments[1] : undefined;
      var callback = arguments.length > 2 ? arguments[2] : undefined;

      if (!callback && typeof query === 'function') {
        callback = query;
        query = options;
        options = {};
      } // handle scenarios where options are not provided


      if (!query) {
        query = options;
        options = {};
      }

      var err = utils.optionsUndefined(options, this.config, ['_index']);

      if (err) {
        return utils.promiseRejectOrCallback(err, callback);
      }

      var index = utils.getIndexSyntax(options, this.config);
      options.query = utils.exclude(options, this.paramExcludes);
      options.path = utils.pathAppend(index, '_query');
      return this.request["delete"](options, query, callback);
    } // http://www.elasticsearch.org/guide/reference/api/explain/

  }, {
    key: "explain",
    value: function explain() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var query = arguments.length > 1 ? arguments[1] : undefined;
      var callback = arguments.length > 2 ? arguments[2] : undefined;

      if (!callback && typeof query === 'function') {
        callback = query;
        query = options;
        options = {};
      }

      var err = utils.optionsUndefined(options, this.config, ['_index', '_id']);

      if (err) {
        return utils.promiseRejectOrCallback(err, callback);
      }

      var index = utils.getIndexSyntax(options, this.config);
      options.query = utils.exclude(options, this.paramExcludes);
      options.path = utils.pathAppend(index, '_explain', options._id); // documentation indicates GET method...
      // sending POST data via GET not typical, using POST instead

      return this.request.post(options, query, callback);
    } // http://www.elasticsearch.org/guide/reference/api/get/

  }, {
    key: "get",
    value: function get() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var callback = arguments.length > 1 ? arguments[1] : undefined;

      if (!callback && typeof options === 'function') {
        callback = options;
        options = {};
      }

      var err = utils.optionsUndefined(options, this.config, ['_index', '_id']);

      if (err) {
        return utils.promiseRejectOrCallback(err, callback);
      }

      if ((0, _isArray["default"])(options._id)) {
        var _context2;

        var docs = [];
        (0, _forEach["default"])(_context2 = options._id).call(_context2, function (id) {
          docs.push({
            _id: id
          });
        });
        return this.multiGet(options, docs, callback);
      }

      var includeSource = options._source && options._source !== false,
          index = utils.getIndexSyntax(options, this.config);
      options.query = utils.exclude(options, this.paramExcludes);
      options.path = utils.pathAppend(index, includeSource ? '_source' : '_doc', options._id); // optionally add source filters if _source is not a boolean value

      if (includeSource && typeof options._source !== 'boolean') {
        options.query._source = options._source;
      }

      return this.request.get(options, callback);
    } // http://www.elasticsearch.org/guide/reference/api/index_/
    // .add to ease backwards compatibility

  }, {
    key: "index",
    value: function index() {
      return this.add.apply(this, arguments);
    } // http://www.elasticsearch.org/guide/reference/api/multi-get/

  }, {
    key: "multiGet",
    value: function multiGet() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var docs = arguments.length > 1 ? arguments[1] : undefined;
      var callback = arguments.length > 2 ? arguments[2] : undefined;

      if (!callback && typeof docs === 'function') {
        callback = docs;
        docs = options;
        options = {};
      }

      if (!callback && typeof options === 'function') {
        callback = options;
        docs = null;
        options = {};
      } // handle scenarios where options are not provided


      if (!docs && (0, _isArray["default"])(options)) {
        docs = options;
        options = {};
      }

      var missingIndex = false,
          self = this;
      (0, _forEach["default"])(docs).call(docs, function (doc) {
        doc._index = doc._index || options._index || self.config._index || null;

        if (!doc._index || doc._index === null) {
          missingIndex = true;
          return;
        }
      });

      if (missingIndex) {
        return utils.promiseRejectOrCallback(new Error('at least 1 or more docs supplied is missing index'), callback);
      }

      options.path = utils.pathAppend('_mget'); // documentation indicates GET method...
      // sending POST data via GET not typical, using POST instead

      return this.request.post(options, {
        docs: docs
      }, callback);
    } // http://www.elasticsearch.org/guide/reference/api/multi-search/
    // Note: Formats input queries as follows in POST data:
    //
    // { query : {} } \n
    // { query : {} } \n
    // { query : {} } \n
    //

  }, {
    key: "multiSearch",
    value: function multiSearch() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var queries = arguments.length > 1 ? arguments[1] : undefined;
      var callback = arguments.length > 2 ? arguments[2] : undefined;

      if (!callback && typeof queries === 'function') {
        callback = queries;
        queries = options;
        options = {};
      } // handle scenarios where options are not provided


      if (!queries && (0, _isArray["default"])(options)) {
        queries = options;
        options = {};
      }

      if (!(0, _isArray["default"])(queries)) {
        return utils.promiseRejectOrCallback(new Error('queries provided must be in array format'), callback);
      }

      var index = utils.getIndexSyntax(options, null),
          // specifically want to exclude defaults
      serializedQueries = '';
      options.query = utils.exclude(options, this.paramExcludes);
      options.path = utils.pathAppend(index, '_msearch');
      (0, _forEach["default"])(queries).call(queries, function (query) {
        serializedQueries += (0, _stringify["default"])(query);
        serializedQueries += '\n';
      }); // documentation indicates GET method...
      // sending POST data via GET not typical, using POST instead

      return this.request.post(options, serializedQueries, callback);
    }
  }, {
    key: "query",
    value: function query() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var _query = arguments.length > 1 ? arguments[1] : undefined;

      var callback = arguments.length > 2 ? arguments[2] : undefined;

      if (!callback && typeof _query === 'function') {
        callback = _query;
        _query = options;
        options = {};
      } // handle scenarios where only the query is provided


      if (!_query) {
        _query = options;
        options = {};
      }

      var err = utils.optionsUndefined(options, this.config, ['_index']);

      if (err) {
        return utils.promiseRejectOrCallback(err, callback);
      }

      var index = utils.getIndexSyntax(options, this.config);
      options.query = utils.exclude(options, this.paramExcludes);
      options.path = utils.pathAppend(index, '_search'); // documentation indicates GET method...
      // sending POST data via GET not typical, using POST instead

      return this.request.post(options, _query, callback);
    } // http://www.elasticsearch.org/guide/reference/api/search/
    // .query to ease backwards compatibility

  }, {
    key: "search",
    value: function search() {
      return this.query.apply(this, arguments);
    } // http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/search-request-scroll.html

  }, {
    key: "scroll",
    value: function scroll() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var scrollId = arguments.length > 1 ? arguments[1] : undefined;
      var callback = arguments.length > 2 ? arguments[2] : undefined;

      if (!callback && typeof scrollId === 'function') {
        callback = scrollId;
        scrollId = options;
        options = {};
      }

      var err = utils.optionsUndefined(options, this.config, ['scroll']);

      if (err) {
        return utils.promiseRejectOrCallback(err, callback);
      }

      options.query = utils.exclude(options, this.paramExcludes);
      options.path = utils.pathAppend('_search/scroll'); // re-map to payload expected by ES6

      if (typeof scrollId === 'string') {
        scrollId = {
          scroll: options.scroll,
          'scroll_id': scrollId
        };
      } // documentation indicates GET method...
      // sending POST data via GET not typical, using POST instead


      return this.request.post(options, scrollId, callback);
    } // http://www.elasticsearch.org/guide/reference/api/search/term-suggest/
    // fix for issue #29

  }, {
    key: "suggest",
    value: function suggest() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var query = arguments.length > 1 ? arguments[1] : undefined;
      var callback = arguments.length > 2 ? arguments[2] : undefined;

      if (!callback && typeof query === 'function') {
        callback = query;
        query = options;
        options = {};
      } // check for scenarios where options are not provided


      if (!query && options.suggest) {
        query = options;
        options = {};
      }

      var index = utils.getIndexSyntax(options, this.config);
      options.query = utils.exclude(options, this.paramExcludes); // NOTE: in 5.0 _suggest deprecated in favor of _search endpoint
      // https://www.elastic.co/guide/en/elasticsearch/reference/current/search-suggesters.html

      options.path = utils.pathAppend(index, '_search');
      return this.request.post(options, query, callback);
    } // http://www.elasticsearch.org/guide/reference/api/update/

  }, {
    key: "update",
    value: function update() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var doc = arguments.length > 1 ? arguments[1] : undefined;
      var callback = arguments.length > 2 ? arguments[2] : undefined;

      if (!callback && typeof doc === 'function') {
        callback = doc;
        doc = options;
        options = {};
      } // attempt to account for missing options


      if (!doc && (options.script || options.doc)) {
        doc = options;
        options = {};
      }

      var err = utils.optionsUndefined(options, this.config, ['_index', '_id']);

      if (err) {
        return utils.promiseRejectOrCallback(err, callback);
      } // fix for #36 - script can be blank, but not missing


      if ((doc.script === null || typeof doc.script === 'undefined') && !doc.doc) {
        return utils.promiseRejectOrCallback(new Error('script or doc is required for update operation'), callback);
      }

      var index = utils.getIndexSyntax(options, this.config);
      options.query = utils.exclude(options, this.paramExcludes);
      options.path = utils.pathAppend(index, '_update', options._id);
      return this.request.post(options, doc, callback);
    } // http://www.elasticsearch.org/guide/reference/api/validate/

  }, {
    key: "validate",
    value: function validate() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var query = arguments.length > 1 ? arguments[1] : undefined;
      var callback = arguments.length > 2 ? arguments[2] : undefined;

      if (!callback && typeof query === 'function') {
        callback = query;
        query = options;
        options = {};
      } // handle scenarios where options are not provided


      if (!query && options.query) {
        query = options;
        options = {};
      }

      var err = utils.optionsUndefined(options, this.config, ['_index']);

      if (err) {
        return utils.promiseRejectOrCallback(err, callback);
      }

      var index = utils.getIndexSyntax(options, this.config);
      options.query = utils.exclude(options, this.paramExcludes);
      options.path = utils.pathAppend(index, '_validate/query'); // documentation indicates GET method...
      // sending POST data via GET not typical, using POST instead

      return this.request.post(options, query, callback);
    }
  }]);
  return Core;
}();

module.exports = {
  Core: Core
};
//# sourceMappingURL=core.js.map
