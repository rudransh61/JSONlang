"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js-stable/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.exclude = exclude;
exports.getIndexSyntax = getIndexSyntax;
exports.getFieldSyntax = getFieldSyntax;
exports.getNodeSyntax = getNodeSyntax;
exports.getTypeSyntax = getTypeSyntax;
exports.optionsUndefined = optionsUndefined;
exports.promiseRejectOrCallback = promiseRejectOrCallback;
exports.promiseResolveOrCallback = promiseResolveOrCallback;
exports.pathAppend = pathAppend;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/toConsumableArray"));

var _forEach = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/for-each"));

var _keys = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/keys"));

var _indexOf = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/index-of"));

var _isArray = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/array/is-array"));

var _every = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/every"));

var _promise = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/promise"));

var _filter = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/filter"));

var _map = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/map"));

var _path = _interopRequireDefault(require("path"));

/*
	Exclude keys from an object.
*/
function exclude(source, excludes) {
  var _context;

  var result = {};
  (0, _forEach["default"])(_context = (0, _keys["default"])(source)).call(_context, function (key) {
    if ((0, _indexOf["default"])(excludes).call(excludes, key) === -1) {
      result[key] = source[key];
    }
  });
  return result;
}
/*
	Looks through request options and lib config data to determine
	the index to use for an operation.

	Supports (and favors over single index) the multi-index syntax
	if an array of index names are supplied (via indices).

	Output is formatted as 'indexName' or 'indexName1,indexName2' or ''

	http://www.elasticsearch.org/guide/reference/api/multi-index/
*/


function getIndexSyntax() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var syntax = '';

  if (options._indices && (0, _isArray["default"])(options._indices)) {
    syntax = options._indices.join(',');
  } else if (options._index) {
    syntax = options._index;
  } else if (config && config._indices && (0, _isArray["default"])(config._indices)) {
    syntax = config._indices.join(',');
  } else if (config && config._index) {
    syntax = config._index;
  }

  return syntax;
}
/*
	Looks through request options to determine the field to use for
	an operation.

	Supports (and favors over single field) multi field syntax
	if an array of field names are supplied (via fields

	Output is formatted as 'fieldName' or 'fieldName1,fieldName2' or ''
*/


function getFieldSyntax() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var syntax = '';

  if (options.fields && (0, _isArray["default"])(options.fields)) {
    syntax = options.fields.join(',');
  } else if (options.field) {
    syntax = options.field;
  }

  if (options.stored_fields && (0, _isArray["default"])(options.stored_fields)) {
    syntax = options.stored_fields.join(',');
  } else if (options.store_field) {
    syntax = options.store_field;
  }

  return syntax;
}
/*
	Looks through request options and lib config data to determine
	the node to use for an operation.

	Supports (and favors over single node) the multi node syntax
	if an array of node names are supplied (via nodes).

	Output is formatted as 'nodeName' or 'nodeName1,nodeName2' or ''
*/


function getNodeSyntax() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var syntax = '';

  if (options.nodes && (0, _isArray["default"])(options.nodes)) {
    syntax = options.nodes.join(',');
  } else if (options.node) {
    syntax = options.node;
  } else if (config && config.nodes && (0, _isArray["default"])(config.nodes)) {
    syntax = config.nodes.join(',');
  } else if (config && config.node) {
    syntax = config.node;
  }

  return syntax;
}
/*
	Looks through request options and lib config data to determine
	the type syntax to use for an operation.

	Supports (and favors over single type) the multi-type syntax
	if an array of type names are supplied (via types).

	Output is formatted as 'typeName' or 'typeName1,typeName2' or ''
*/


function getTypeSyntax() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var syntax = '';

  if (options._types && (0, _isArray["default"])(options._types)) {
    syntax = options._types.join(',');
  } else if (options._type) {
    syntax = options._type;
  } else if (config && config._types && (0, _isArray["default"])(config._types)) {
    syntax = config._types.join(',');
  } else if (config && config._type) {
    syntax = config._type;
  }

  return syntax;
}
/*
	Convenience method for ensuring an expected key exists either in
	request options or lib config data. As the operation iterates
	through each key supplied in keys, if it is not found as a property
	in options or config, the function returns an Error.

	If the specified keys are found, false is returned (indicating no
	options are undefined).

	if '_index' or '_type' is specified, the method will accept the
	pluralized versions of those properties without returning an
	Error.
*/


function optionsUndefined() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var keys = arguments.length > 2 ? arguments[2] : undefined;
  var error;
  (0, _every["default"])(keys).call(keys, function (key) {
    if (key === '_index' && (options.hasOwnProperty('_indices') || config.hasOwnProperty('_indices'))) {
      return true;
    }

    if (key === '_type' && (options.hasOwnProperty('_types') || config.hasOwnProperty('_types'))) {
      return true;
    }

    if (!options.hasOwnProperty(key) && !config.hasOwnProperty(key)) {
      error = new Error(key + ' is required');
      return false;
    }

    return true;
  });
  return error || false;
}

function promiseRejectOrCallback(err, callback) {
  if (!callback) {
    return _promise["default"].reject(err);
  }

  return callback(err);
}

function promiseResolveOrCallback(result, callback) {
  if (!callback) {
    return _promise["default"].resolve(result);
  }

  return callback(null, result);
}
/*
	Convenience method used for building path string used
	when issuing the HTTP/HTTPS request. If the resource param
	is undefined, empty or false an empty sting is returned.

	If the input resource string has a value, it is returned
	with a '/' prepend.

	pathAppend('kitteh')

	Outputs: '/kitteh'
*/


function pathAppend() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  var filteredArgs = (0, _filter["default"])(args).call(args, function (arg) {
    var valid = (arg || arg === 0) && typeof arg !== 'undefined';
    return valid;
  });

  if (filteredArgs && filteredArgs.length && filteredArgs[0].charAt(0) !== '/') {
    filteredArgs[0] = ['/', filteredArgs[0]].join('');
  }

  return _path["default"].join.apply(_path["default"], (0, _toConsumableArray2["default"])((0, _map["default"])(filteredArgs).call(filteredArgs, function (arg) {
    return arg && arg.toString ? arg.toString() : arg;
  })));
}
//# sourceMappingURL=utils.js.map
